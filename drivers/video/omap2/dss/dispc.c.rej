--- drivers/video/omap2/dss/dispc.c	2012-12-31 06:33:44.000000000 +0900
+++ drivers/video/omap2/dss/dispc.c	2012-11-23 18:12:42.000000000 +0900
@@ -2834,7 +2792,7 @@
 					msecs_to_jiffies(100)))
 			DSSERR("timeout waiting for FRAME DONE\n");
 
-		r = omap_dispc_unregister_isr_sync(dispc_disable_isr,
+		r = omap_dispc_unregister_isr(dispc_disable_isr,
 				&frame_done_completion, irq);
 
 		if (r)
@@ -2882,24 +2840,20 @@
 	/* XXX I understand from TRM that we should only wait for the
 	 * current field to complete. But it seems we have to wait
 	 * for both fields */
-#ifdef CONFIG_MACH_LGE_COSMO
         if(!cpu_is_omap44xx()) {  //mo2sanghyun.lee 2012.06.23 
-#endif
-	if (!wait_for_completion_timeout(&frame_done_completion,
-				msecs_to_jiffies(100)))
-		DSSERR("timeout waiting for EVSYNC\n");
-
-	/* Don't wait for the odd field  in the case of HDMI */
-	if (type != OMAP_DISPLAY_TYPE_HDMI) {
-		if (!wait_for_completion_timeout(&frame_done_completion,
-					msecs_to_jiffies(100)))
-			DSSERR("timeout waiting for EVSYNC\n");
-	}
-#ifdef CONFIG_MACH_LGE_COSMO
+            if (!wait_for_completion_timeout(&frame_done_completion,
+            		msecs_to_jiffies(100)))
+            DSSERR("timeout waiting for EVSYNC\n");
+
+            /* Don't wait for the odd field  in the case of HDMI */
+            if (type != OMAP_DISPLAY_TYPE_HDMI) {
+            if (!wait_for_completion_timeout(&frame_done_completion,
+            			msecs_to_jiffies(100)))
+            	DSSERR("timeout waiting for EVSYNC\n");
+            }
         }
-#endif
-
-	r = omap_dispc_unregister_isr_sync(dispc_disable_isr,
+        
+	r = omap_dispc_unregister_isr(dispc_disable_isr,
 			&frame_done_completion,
 			DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD
 						| DISPC_IRQ_FRAMEDONETV);
@@ -4092,8 +4042,7 @@
 }
 EXPORT_SYMBOL(omap_dispc_register_isr);
 
-/* WARNING: callback might be executed even after this function returns! */
-int omap_dispc_unregister_isr_nosync(omap_dispc_isr_t isr, void *arg, u32 mask)
+int omap_dispc_unregister_isr(omap_dispc_isr_t isr, void *arg, u32 mask)
 {
 	int i;
 	unsigned long flags;
@@ -4125,37 +4074,7 @@
 
 	return ret;
 }
-EXPORT_SYMBOL(omap_dispc_unregister_isr_nosync);
-
-/*
- * Ensure that callback <isr> will NOT be executed after this function
- * returns. Must be called from sleepable context, though!
- */
-int omap_dispc_unregister_isr_sync(omap_dispc_isr_t isr, void *arg, u32 mask)
-{
-	int ret;
-
-	ret = omap_dispc_unregister_isr_nosync(isr, arg, mask);
-
-	/* Task context is not really needed. But if we're called from atomic
-	 * context, it is probably from DISPC IRQ, where we will deadlock.
-	 * So use might_sleep() to catch potential deadlocks.
-	 */
-	might_sleep();
-
-#if defined(CONFIG_SMP)
-	/* DISPC IRQ executes callbacks with dispc.irq_lock released. Hence
-	 * unregister_isr() and DISPC IRQ might be running in parallel on
-	 * different CPUs. So there is a chance that a callback is executed
-	 * even though it has been unregistered. Add a barrier, in order to
-	 * ensure that after returning from this function, the new DISPC IRQ
-	 * will use an updated callback array, and NOT its cached copy.
-	 */
-	synchronize_irq(dispc.irq);
-#endif
-
-	return ret;
-}
+EXPORT_SYMBOL(omap_dispc_unregister_isr);
 
 #ifdef DEBUG
 static void print_irq_status(u32 status)
@@ -4540,8 +4459,7 @@
 
 	timeout = wait_for_completion_timeout(&completion, timeout);
 
-	omap_dispc_unregister_isr_sync(dispc_irq_wait_handler, &completion,
-			irqmask);
+	omap_dispc_unregister_isr(dispc_irq_wait_handler, &completion, irqmask);
 
 	if (timeout == 0)
 		return -ETIMEDOUT;
@@ -4576,8 +4494,7 @@
 	timeout = wait_for_completion_interruptible_timeout(&completion,
 			timeout);
 
-	omap_dispc_unregister_isr_sync(dispc_irq_wait_handler, &completion,
-			irqmask);
+	omap_dispc_unregister_isr(dispc_irq_wait_handler, &completion, irqmask);
 
 	if (timeout == 0)
 		r = -ETIMEDOUT;
