--- drivers/broadcast/tdmb/t3900/src/broadcast_t3900.c	2012-12-31 06:33:44.000000000 +0900
+++ drivers/broadcast/tdmb/t3900/src/broadcast_t3900.c	2012-11-23 18:12:31.000000000 +0900
@@ -2,6 +2,9 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/device.h>
+//#include <linux/slab.h>	/* kmalloc */
+
+//#include <linux/i2c.h>     /* HOST Interface I2C */
 #include <linux/pm.h>
 
 #include <linux/spi/spi.h>         /* HOST Interface SPI */
@@ -16,21 +19,28 @@
 #include "../../broadcast_tdmb_drv_ifdef.h"
 #include "../inc/broadcast_t3900.h"
 
-#define PM_QOS						/* For P2(PM QoS) */
-#undef PMIC_CLOCK_SHARING			/* For P2(No clock sharing) */
-#undef ANTENNA_SWITCHING			/* For P2(No antenna switching) */
+#define PM_QOS							// For P2(PM QoS)
+#undef PMIC_CLOCK_SHARING				// For P2(No clock sharing)
+#undef ANTENNA_SWITCHING				// For P2(No antenna switching)
+#undef DELAY_USING_WAIT_EVENT_TIMEOUT	// wait_event_timeout instead of msleep
 
 #ifdef ANTENNA_SWITCHING
 #include CONFIG_BOARD_HEADER_FILE
-#endif /* ANTENNA_SWITCHING */
+#endif // ANTENNA_SWITCHING
+
+#ifdef DELAY_USING_WAIT_EVENT_TIMEOUT
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/jiffies.h>
+#endif // DELAY_USING_WAIT_EVENT_TIMEOUT
 
 #ifdef PM_QOS
 #include <linux/pm_qos_params.h>
-#endif /* PM_QOS */
+#endif // PM_QOS
 
 #ifdef PMIC_CLOCK_SHARING
 #include <mach/msm_xo.h>
-#endif /* PMIC_CLOCK_SHARING */
+#endif // PMIC_CLOCK_SHARING
 
 /* T3900 driver contrl block */
 struct tdmb_t3900_ctrl_blk 
@@ -46,7 +56,7 @@
 
 #ifdef PM_QOS
 	struct pm_qos_request_list      pm_req_list;     
-#endif /* PM_QOS */
+#endif // PM_QOS
 };
 
 static struct tdmb_t3900_ctrl_blk t3900_ctrl_info;
@@ -54,7 +64,7 @@
 #ifdef PMIC_CLOCK_SHARING
 static const char *id = "TDMB";
 static struct msm_xo_voter *xo_handle_tdmb;
-#endif /* PMIC_CLOCK_SHARING */
+#endif // PMIC_CLOCK_SHARING
 
 // -------------------------------------------------------------------- 
 // P2 DMB GPIOs
@@ -64,25 +74,74 @@
 
 #ifdef ANTENNA_SWITCHING
 /*
- * Extended GPIOs from PMIC8921
- * Refer to kernel/arch/arm/mach-msm/lge/board_d1l_pm.c for registration.
- */
-#define DMB_ANT_SEL_EAR			(PM8921_GPIO_PM_TO_SYS(16))
-#define DMB_ANT_SEL_INN			(PM8921_GPIO_PM_TO_SYS(17))
-#endif /* ANTENNA_SWITCHING */
+* Extended GPIOs from PMIC8921
+* Refer to kernel/arch/arm/mach-msm/lge/board_d1l_pm.c for registration.
+*/
+#define DMB_ANT_SEL_EAR		16
+#define DMB_ANT_SEL_INN		17
+#endif // ANTENNA_SWITCHING
 
 //---------------------------------------------------------------------
 
+#ifdef DELAY_USING_WAIT_EVENT_TIMEOUT
+enum waitsleep_state { WAITSLEEP_IS_NOT_S = 0, WAITSLEEP_IS_S= 1, WAITEXIT_USER_STOP_S =2};
+static DECLARE_WAIT_QUEUE_HEAD(msleep_wait_queue);  /*wait_event_timeout queue */
+static enum waitsleep_state msleep_exit_condition = WAITSLEEP_IS_NOT_S;  /* sleep exit condition not timeout(sleep) */
+static uint32 msleep_wait_queue_init = 0;
+#else /* DELAY_USING_WAIT_EVENT_TIMEOUT */
 static uint32 user_stop_flg = 0;
+//static uint32 mdelay_in_flg = 0;
+#endif  /* DELAY_USING_WAIT_EVENT_TIMEOUT */
 
-/* ============================================================== */
-/*  Internal Functions                                                                                                                */
-/* ============================================================== */
 static int broadcast_t3900_probe(struct spi_device *spi);
 static int broadcast_t3900_remove(struct spi_device *spi);
 static int broadcast_t3900_suspend(struct spi_device *spi, pm_message_t mesg);
 static int broadcast_t3900_resume(struct spi_device *spi);
 
+
+#ifdef DELAY_USING_WAIT_EVENT_TIMEOUT
+void tdmb_t3900_set_userstop(void)
+{
+	if(msleep_exit_condition == WAITSLEEP_IS_S)
+	{
+		printk("dmb-driver sleep state, so send user stop\n");
+		msleep_exit_condition = WAITEXIT_USER_STOP_S;
+		wake_up(&msleep_wait_queue);
+	}
+	else
+	{
+		msleep_exit_condition = WAITSLEEP_IS_NOT_S;
+	}
+}
+
+int tdmb_t3900_mdelay(int32 ms)
+{
+	int rc = 1;
+	int wait_rc = OK;
+
+	if(msleep_wait_queue_init == 0)
+	{
+		init_waitqueue_head(&msleep_wait_queue);
+		msleep_wait_queue_init = 1;
+	}
+
+	printk("Enter tdmb_t3900_mdelay ms = (%d), jitter = (%d)", ms,msecs_to_jiffies(ms));
+	msleep_exit_condition = WAITSLEEP_IS_S;
+	/* sleep during msec set or msleep_exit_condition meet */
+	wait_rc = wait_event_timeout(msleep_wait_queue, 
+		(msleep_exit_condition == WAITEXIT_USER_STOP_S), msecs_to_jiffies(ms));
+
+	/* wait exit becaus of user stop not timeout */
+	if(msleep_exit_condition == WAITEXIT_USER_STOP_S)
+	{
+		printk("dmb-user stop msleep_exit_condition=(%d)\ time = (%d)n", msleep_exit_condition, ms);
+		rc = 0;
+	}
+	
+	msleep_exit_condition = WAITSLEEP_IS_NOT_S;
+	return rc;
+}
+#else /* DELAY_USING_WAIT_EVENT_TIMEOUT */
 void tdmb_t3900_set_userstop(int mode)
 {
 	user_stop_flg = mode;
@@ -94,6 +153,7 @@
 	int32	wait_loop =0;
 	int32	wait_ms = ms;
 
+	//mdelay_in_flg = 1;
 	if(ms > 100)
 	{
 		wait_loop = (ms /100);   /* 100, 200, 300 more only , Otherwise this must be modified e.g (ms + 40)/50 */
@@ -102,7 +162,7 @@
 
 	do
 	{
-		mdelay(wait_ms);
+		msleep(wait_ms);
 		if(user_stop_flg == 1)
 		{
 			printk("~~~~~~~~ Ustop flag is set so return false ms =(%d)~~~~~~~\n", ms);
@@ -113,17 +173,18 @@
 
 	return rc;
 }
+#endif  /* DELAY_USING_WAIT_EVENT_TIMEOUT */
 
 void tdmb_t3900_must_mdelay(int32 ms)
 {
-	mdelay(ms);
+	msleep(ms);
 }
 
 int tdmb_t3900_power_on(void)
 {
 #ifdef PMIC_CLOCK_SHARING
 	int rc;
-#endif /* PMIC_CLOCK_SHARING */
+#endif
 
 	if ( t3900_ctrl_info.is_power_on == FALSE )
 	{
@@ -133,7 +194,7 @@
 		if(pm_qos_request_active(&t3900_ctrl_info.pm_req_list)) {
 			pm_qos_update_request(&t3900_ctrl_info.pm_req_list, 20);	
 		}
-#endif /* PM_QOS */
+#endif // PM_QOS
 
 		wake_lock(&t3900_ctrl_info.wake_lock);
 		
@@ -145,29 +206,29 @@
 			msm_xo_put(xo_handle_tdmb);
 			return FALSE;
 		}
-#endif /* PMIC_CLOCK_SHARING */
+#endif // PMIC_CLOCK_SHARING
 
 #ifdef ANTENNA_SWITCHING
-		gpio_set_value_cansleep(DMB_ANT_SEL_EAR, 0);
-		gpio_set_value_cansleep(DMB_ANT_SEL_INN, 1);
-#endif /* ANTENNA_SWITCHING */
+		gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_EAR), 0);
+		gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_INN), 1);
+#endif // ANTENNA_SWITCHING
 
 		/* T3900 Power On Sequence */
 		gpio_set_value(T3900_DMB_EN, 0);
 		gpio_set_value(T3900_DMB_RESET_N, 0);
-		udelay(200);
+		udelay(50);
 		
 		gpio_set_value(T3900_DMB_EN, 1);
-		mdelay(3);
+		udelay(1000);
 
 		gpio_set_value(T3900_DMB_RESET_N, 1);
-		mdelay(2);
+		udelay(1500);
 
 		gpio_set_value(T3900_DMB_RESET_N, 0);
-		mdelay(1);
+		udelay(700);
 
 		gpio_set_value(T3900_DMB_RESET_N, 1);
-		udelay(200);
+		udelay(100);
 
 		tdmb_t3900_interrupt_free();
 		t3900_ctrl_info.is_power_on = TRUE;
@@ -179,6 +240,10 @@
 
 	printk("tdmb_t3900_power_on completed \n");
 
+#ifdef DELAY_USING_WAIT_EVENT_TIMEOUT
+	msleep_exit_condition = WAITSLEEP_IS_NOT_S;
+#endif // DELAY_USING_WAIT_EVENT_TIMEOUT	
+
 	return TRUE;
 
 }
@@ -193,7 +258,7 @@
 		{
 			msm_xo_mode_vote(xo_handle_tdmb, MSM_XO_MODE_OFF);
 		}		
-#endif /* PMIC_CLOCK_SHARING */
+#endif // PMIC_CLOCK_SHARING
 
 		tdmb_t3900_interrupt_lock();
 		t3900_ctrl_info.is_power_on = FALSE;
@@ -205,9 +270,9 @@
 		udelay(500);
 
 #ifdef ANTENNA_SWITCHING
-        gpio_set_value_cansleep(DMB_ANT_SEL_EAR, 1); 		/* For ESD Test */
-        gpio_set_value_cansleep(DMB_ANT_SEL_INN, 0);
-#endif /* ANTENNA_SWITCHING */
+        gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_EAR), 1); // For ESD Test(from i-Pjt)
+        gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_INN), 0);
+#endif // ANTENNA_SWITCHING
 
 		wake_unlock(&t3900_ctrl_info.wake_lock);
 
@@ -216,7 +281,7 @@
 		if(pm_qos_request_active(&t3900_ctrl_info.pm_req_list)) {
 			pm_qos_update_request(&t3900_ctrl_info.pm_req_list, PM_QOS_DEFAULT_VALUE);	
 		}
-#endif /* PM_QOS */
+#endif // PM_QOS
 
 	}
 	else
@@ -226,6 +291,9 @@
 
 	printk("tdmb_t3900_power_off completed \n");
 		
+#ifdef DELAY_USING_WAIT_EVENT_TIMEOUT
+	msleep_exit_condition = WAITSLEEP_IS_NOT_S;
+#endif // DELAY_USING_WAIT_EVENT_TIMEOUT	
 
 	return TRUE;
 }
@@ -234,21 +302,21 @@
 {
 #ifdef ANTENNA_SWITCHING
     if(LGE_BROADCAST_TDMB_ANT_TYPE_INTENNA == sel) {
-        gpio_set_value_cansleep(DMB_ANT_SEL_EAR, 0);
-        gpio_set_value_cansleep(DMB_ANT_SEL_INN, 1);
-
+        gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_EAR), 0);
+        gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_INN), 1);
+        // printk("ANT is %d ",sel);
         return TRUE;
     }
     else if(LGE_BROADCAST_TDMB_ANT_TYPE_EARANT == sel) {
     
-        gpio_set_value_cansleep(DMB_ANT_SEL_EAR, 1);
-        gpio_set_value_cansleep(DMB_ANT_SEL_INN, 0);
-
+        gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_EAR), 1);
+        gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_INN), 0);
+        // printk("ANT is %d ",sel);
         return TRUE;
     }
-#else /* ANTENNA_SWITCHING */
+#else // ANTENNA_SWITCHING
 	return TRUE;
-#endif /* ANTENNA_SWITCHING */
+#endif // ANTENNA_SWITCHING
 
 	return FALSE;
 }
@@ -302,18 +370,18 @@
 		.rx_buf		= rx_data,
 		.len			= tx_length+rx_length,
 
-// For P2 porting
+// Modified by prajuna 20120208 for P2 porting
 #ifndef CONFIG_LGE_SPI_SLAVE
-		.cs_change	= 0,									/* pdata->force_cs_mode = 0 */
-#endif /* CONFIG_LGE_SPI_SLAVE */
+		.cs_change	= 0,									// pdata->force_cs_mode = 0;
+#endif // CONFIG_LGE_SPI_SLAVE
 	};
 	
 	struct spi_message	m;
 
-// For P2 porting
+// Modified by prajuna 20120208 for P2 porting
 #ifndef CONFIG_LGE_SPI_SLAVE
-	m.is_dma_mapped = 1;									/* pdata->dma_mode = 1 */
-#endif /* CONFIG_LGE_SPI_SLAVE */
+	m.is_dma_mapped = 1;									// pdata->dma_mode = 1;
+#endif // CONFIG_LGE_SPI_SLAVE
 
 	//printk("tdmb_t3900_spi_write_read start\n");
 
@@ -363,7 +431,7 @@
 		}
 	}
 }
-#endif /* 0 */
+#endif // 0
 
 static irqreturn_t broadcast_tdmb_spi_isr(int irq, void *handle)
 {
@@ -441,7 +509,7 @@
 	t3900_ctrl_info.spi_ptr->mode 			= SPI_MODE_0;
 	t3900_ctrl_info.spi_ptr->bits_per_word 	= 8;
 
-	// For P2 porting
+	// Modified by prajuna 20120208 for P2 porting
 	//t3900_ctrl_info.spi_ptr->max_speed_hz 	= (5400 * 1000);
 	t3900_ctrl_info.spi_ptr->max_speed_hz 	= (6 * 1000 * 1000);
 
@@ -450,7 +518,7 @@
 
 	INIT_WORK(&t3900_ctrl_info.spi_work, broacast_tdmb_spi_work);
 
-	// For P2 porting
+	// Modified by prajuna 20120209 for P2 porting
 	t3900_ctrl_info.spi_wq = create_singlethread_workqueue("tdmb_spi_wq");
 	// t3900_ctrl_info.spi_wq = create_rt_workqueue("tdmb_spi_wq");
 	
@@ -466,19 +534,18 @@
 	printk("broadcast_t3900_probe request_irq=%d\n", rc);
 
 #ifdef ANTENNA_SWITCHING
-    gpio_set_value_cansleep(DMB_ANT_SEL_EAR, 1); // For ESD Test(from i-Pjt)
-    gpio_set_value_cansleep(DMB_ANT_SEL_INN, 0);
-#endif /* ANTENNA_SWITCHING */
+    gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_EAR), 1); // For ESD Test(from i-Pjt)
+    gpio_set_value_cansleep(PM8921_GPIO_PM_TO_SYS(DMB_ANT_SEL_INN), 0);
+#endif // ANTENNA_SWITCHING
 
 #ifdef PMIC_CLOCK_SHARING
 	xo_handle_tdmb = msm_xo_get(MSM_XO_TCXO_D1, id);
 	if(IS_ERR(xo_handle_tdmb))
 	{
 		pr_err("Failed to get MSM_XO_TCXO_D1 handle for TDMB (%ld)\n", PTR_ERR(xo_handle_tdmb));
-
 		return FALSE;
 	}
-#endif /* PMIC_CLOCK_SHARING */
+#endif // PMIC_CLOCK_SHARING
 
 	tdmb_t3900_interrupt_lock();
 
@@ -490,7 +557,7 @@
 
 #ifdef PM_QOS
 	pm_qos_add_request(&t3900_ctrl_info.pm_req_list, PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
-#endif /* PM_QOS */
+#endif // PM_QOS
 
 	printk("broadcast_t3900_probe End. \n");
 	
@@ -511,7 +578,7 @@
 
 #ifdef PM_QOS
 	pm_qos_remove_request(&t3900_ctrl_info.pm_req_list);
-#endif /* PM_QOS */
+#endif // PM_QOS
 
 	memset((unsigned char*)&t3900_ctrl_info, 0x0, sizeof(struct tdmb_t3900_ctrl_blk));
 
@@ -537,7 +604,6 @@
 {
 	int rc;
 
-	//printk("broadcast_tdmb_drv_init\n");
 	printk("%s is called\n", "broadcast_tdmb_drv_init");
 
 	rc = broadcast_tdmb_drv_start();
